<!doctype html><html><head>  <meta charset="utf-8" />  <title>Snake</title>  <style>    body { margin: 0; height: 100vh; display: grid; place-items: center; font-family: system-ui; background: #111; }    #wrap { position: relative; }    canvas { border: 2px solid #222; background: #556B2F; }    .overlay {      position: absolute; inset: 0;      display: none;      align-items: center; justify-content: center;      background: rgba(0,0,0,.55);      color: #fff;    }    .panel {      background: rgba(20,20,20,.9);      border: 1px solid rgba(255,255,255,.12);      border-radius: 14px;      padding: 18px;      min-width: 260px;      box-shadow: 0 10px 30px rgba(0,0,0,.4);    }    .title { font-size: 28px; font-weight: 800; margin: 0 0 10px; }    .row { margin: 12px 0; }    button {      width: 100%;      padding: 10px 12px;      border: 0; border-radius: 10px;      background: #2f6f2f; color: white;      font-size: 16px; font-weight: 700;      cursor: pointer;    }    button.secondary { background: #444; }    button.danger { background: #8b2e2e; }    label { display: block; font-weight: 700; margin-bottom: 6px; }    input[type="range"] { width: 100%; }    .small { opacity: .9; font-size: 13px; }    #hud {      margin-top: 10px;      color: #eee;      display: flex;      justify-content: space-between;      font-weight: 700;    }    .kbd { padding: 2px 6px; border: 1px solid #666; border-radius: 6px; background: rgba(255,255,255,.06); }  </style></head><body>  <div id="wrap">    <canvas id="c" width="400" height="400"></canvas>    <!-- MAIN MENU -->    <div id="menu" class="overlay" style="display:flex;">      <div class="panel">        <div class="title">SNAKE</div>        <div class="row small">Use <span class="kbd">Arrow Keys</span> to move.</div>        <div class="row"><button id="playBtn">Play</button></div>        <div class="row"><button id="optionsBtn" class="secondary">Options</button></div>      </div>    </div>    <!-- OPTIONS MENU -->    <div id="options" class="overlay">      <div class="panel">        <div class="title">Options</div>        <div class="row">          <label for="speed">Speed (ms per step)</label>          <input id="speed" type="range" min="60" max="220" step="10">          <div class="small">Lower = faster. Current: <span id="speedVal"></span> ms</div>        </div>        <div class="row">          <label for="food">Food on screen</label>          <input id="food" type="range" min="1" max="6" step="1">          <div class="small">Current: <span id="foodVal"></span></div>        </div>        <div class="row"><button id="backBtn" class="secondary">Back</button></div>      </div>    </div>    <!-- DEATH SCREEN -->    <div id="dead" class="overlay">      <div class="panel">        <div class="title">You Died</div>        <div class="row small">Score: <span id="finalScore">0</span></div>        <div class="row"><button id="respawnBtn">Respawn</button></div>        <div class="row"><button id="toMenuBtn" class="secondary">Exit to Main Menu</button></div>      </div>    </div>  </div>  <div id="hud" style="width:404px;">    <div>Score: <span id="score">0</span></div>    <div class="small">Pause: <span class="kbd">P</span></div>  </div><script>const canvas = document.getElementById("c");const ctx = canvas.getContext("2d");const menuOverlay = document.getElementById("menu");const optionsOverlay = document.getElementById("options");const deadOverlay = document.getElementById("dead");const playBtn = document.getElementById("playBtn");const optionsBtn = document.getElementById("optionsBtn");const backBtn = document.getElementById("backBtn");const respawnBtn = document.getElementById("respawnBtn");const toMenuBtn = document.getElementById("toMenuBtn");const speedSlider = document.getElementById("speed");const foodSlider = document.getElementById("food");const speedVal = document.getElementById("speedVal");const foodVal = document.getElementById("foodVal");const scoreEl = document.getElementById("score");const finalScoreEl = document.getElementById("finalScore");const SIZE = 20;const COLS = canvas.width / SIZE;const ROWS = canvas.height / SIZE;// Options (defaults)let stepMs = 120;     // lower = fasterlet foodCount = 1;// Game statelet state = "menu";   // menu, options, game, deadlet snake, dir, pendingDir, foods, score, timer, paused;// Smooth rendering state (NEW)let prevSnake = null;let prevFoods = null;let animStart = 0;let animT = 1;function lerp(a, b, t) { return a + (b - a) * t; }function show(overlay) {  menuOverlay.style.display = "none";  optionsOverlay.style.display = "none";  deadOverlay.style.display = "none";  if (overlay) overlay.style.display = "flex";}function startMenu() {  state = "menu";  stopTimer();  show(menuOverlay);  drawBackground();}function startOptions() {  state = "options";  show(optionsOverlay);}function startGame() {  state = "game";  show(null);  resetGame();  startTimer();  draw();}function die() {  state = "dead";  stopTimer();  finalScoreEl.textContent = score;  show(deadOverlay);}function resetGame() {  snake = [{x: 10, y: 10}];  dir = {x: 1, y: 0};  pendingDir = dir;  foods = [];  score = 0;  paused = false;  scoreEl.textContent = score;  spawnFoods();  // Smooth init (NEW)  prevSnake = snake.slice();  prevFoods = foods.slice();  animStart = performance.now();  animT = 1;}function startTimer() {  stopTimer();  // Align smooth timing with tick timing (NEW)  animStart = performance.now();  animT = 1;  timer = setInterval(tick, stepMs);}function stopTimer() {  if (timer) clearInterval(timer);  timer = null;}function drawBackground() {  ctx.fillStyle = "#556B2F";  ctx.fillRect(0, 0, canvas.width, canvas.height);}function samePos(a, b) { return a.x === b.x && a.y === b.y; }function isOnSnake(p) {  for (let i = 0; i < snake.length; i++) {    if (snake[i].x === p.x && snake[i].y === p.y) return true;  }  return false;}function isOnFood(p) {  for (let i = 0; i < foods.length; i++) {    if (foods[i].x === p.x && foods[i].y === p.y) return true;  }  return false;}function spawnOneFood() {  while (true) {    const f = {x: (Math.random()*COLS)|0, y: (Math.random()*ROWS)|0};    if (!isOnSnake(f) && !isOnFood(f)) return f;  }}function spawnFoods() {  foods = [];  for (let i = 0; i < foodCount; i++) {    foods.push(spawnOneFood());  }}function tick() {  if (state !== "game" || paused) return;  // Save previous state for smooth drawing (NEW)  prevSnake = snake.slice();  prevFoods = foods.slice();  animStart = performance.now();  animT = 0;  dir = pendingDir;  const head = snake[0];  const next = {x: head.x + dir.x, y: head.y + dir.y};  // WALLS KILL YOU (no wrap)  if (next.x < 0 || next.x >= COLS || next.y < 0 || next.y >= ROWS) {    die();    return;  }  // Self collision  if (isOnSnake(next)) {    die();    return;  }  snake.unshift(next);  // Eat any food  let ateIndex = -1;  for (let i = 0; i < foods.length; i++) {    if (samePos(next, foods[i])) { ateIndex = i; break; }  }  if (ateIndex !== -1) {    score++;    scoreEl.textContent = score;    foods.splice(ateIndex, 1);    foods.push(spawnOneFood());    // snake grows (no pop)  } else {    snake.pop();  }  // NOTE: do NOT call draw() here anymore â€” animation loop draws smoothly (NEW)}function draw() {  drawBackground();  // foods (grid-locked; interpolates only if array changes mid-step)  ctx.fillStyle = "#f2d7a0";  for (let i = 0; i < foods.length; i++) {    let fx = foods[i].x;    let fy = foods[i].y;    if (prevFoods && prevFoods[i]) {      fx = lerp(prevFoods[i].x, foods[i].x, animT);      fy = lerp(prevFoods[i].y, foods[i].y, animT);    }    ctx.fillRect(fx * SIZE, fy * SIZE, SIZE, SIZE);  }  // snake (smooth between grid squares)  ctx.fillStyle = "#0b3d0b";  for (let i = 0; i < snake.length; i++) {    let x = snake[i].x;    let y = snake[i].y;    if (prevSnake && prevSnake[i]) {      x = lerp(prevSnake[i].x, snake[i].x, animT);      y = lerp(prevSnake[i].y, snake[i].y, animT);    }    ctx.fillRect(x * SIZE, y * SIZE, SIZE, SIZE);  }}// Smooth animation loop (NEW)function animate(now) {  if (state === "game" && !paused) {    animT = (now - animStart) / stepMs;    if (animT > 1) animT = 1;    draw();  }  requestAnimationFrame(animate);}// UI eventsplayBtn.addEventListener("click", startGame);optionsBtn.addEventListener("click", () => { startOptions(); });backBtn.addEventListener("click", startMenu);respawnBtn.addEventListener("click", startGame);toMenuBtn.addEventListener("click", startMenu);// Options slidersfunction syncOptionsUI() {  speedSlider.value = stepMs;  foodSlider.value = foodCount;  speedVal.textContent = stepMs;  foodVal.textContent = foodCount;}speedSlider.addEventListener("input", () => {  stepMs = Number(speedSlider.value);  speedVal.textContent = stepMs;  if (state === "game") startTimer(); // apply immediately if playing});foodSlider.addEventListener("input", () => {  foodCount = Number(foodSlider.value);  foodVal.textContent = foodCount;  if (state === "game") spawnFoods(); // apply immediately if playing});// Keyboard controlsdocument.addEventListener("keydown", (e) => {  const k = e.key;  if (k === "p" || k === "P") {    if (state === "game") paused = !paused;    return;  }  if (state !== "game") return;  // prevent reversing directly  if (k === "ArrowUp" && dir.y !== 1) pendingDir = {x: 0, y: -1};  else if (k === "ArrowDown" && dir.y !== -1) pendingDir = {x: 0, y: 1};  else if (k === "ArrowLeft" && dir.x !== 1) pendingDir = {x: -1, y: 0};  else if (k === "ArrowRight" && dir.x !== -1) pendingDir = {x: 1, y: 0};});// InitsyncOptionsUI();startMenu();requestAnimationFrame(animate);</script></body></html>